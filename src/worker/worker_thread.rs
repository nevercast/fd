use crate::common::{
    MessageFromLearner, MessageFromWorker, ModelTransfer, ModelVersion, ParameterChunkData,
    TransferCompletion,
};
use message_io::{events, network, network::NetEvent, node};
use std::{io, thread};

use super::worker_signals::*;

type WorkerHandler = node::NodeHandler<ThreadSignal>;
type WorkerListener = node::NodeListener<ThreadSignal>;
type WorkerEventReceiver = events::EventReceiver<WorkerSignal>;
type WorkerEventSender = events::EventSender<WorkerSignal>;
type NodeEvent<'a> = node::NodeEvent<'a, ThreadSignal>;

#[derive(Default)]
struct WorkerThreadData {
    parameter_count: Option<usize>,
    transfer: Option<ModelTransfer>,
}

pub struct WorkerThread {
    pub handler: WorkerHandler,
    pub receiver: WorkerEventReceiver,
}

impl Drop for WorkerThread {
    fn drop(&mut self) {
        self.handler.signals().send(ThreadSignal::Stop);
    }
}

impl WorkerThread {
    pub fn new(transport: network::Transport, addr: String) -> io::Result<WorkerThread> {
        // Create event sender and receiver pair for internal communication between background thread and worker.
        let receiver = events::EventReceiver::default();
        let sender = receiver.sender().clone();
        // Create a network node and connect it to the remote server.
        // Handler is also an event sender, listener is an event receiver.
        // This pair is used to communicate with the remote server.
        let (handler, listener) = node::split::<ThreadSignal>();
        let (server, _) = handler.network().connect(transport, addr)?;
        // Handler is an Arc internally, so we can clone it and reuse it for the background thread.
        let thread_handler = handler.clone();
        // Spawn the worker thread to handle the network connection, keeping the thread handle.
        thread::spawn(move || {
            worker_thread_main(server, thread_handler, listener, sender);
        });

        Ok(WorkerThread { handler, receiver })
    }
}

fn worker_thread_main(
    server: network::Endpoint,
    handler: WorkerHandler,
    listener: WorkerListener,
    sender: WorkerEventSender,
) {
    let mut thread_data = WorkerThreadData::default();
    listener.for_each(move |event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => handler.signals().send(ThreadSignal::SendInit),
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                let message: MessageFromLearner = bincode::deserialize(data).unwrap();
                match message {
                    MessageFromLearner::InitialiseWorker { parameter_count } => {
                        thread_data.parameter_count = Some(parameter_count);
                        sender.send(WorkerSignal::ConfigureBuffer(parameter_count));
                    }
                    MessageFromLearner::ParameterChunk {
                        model_version,
                        data,
                    } => {
                        thread_data.transfer =
                            match handle_transfer(&mut thread_data, model_version, data) {
                                TransferCompletion::Complete {
                                    model_version,
                                    model,
                                } => {
                                    sender.send(WorkerSignal::ModelUpdate(model_version, model));
                                    None
                                }
                                TransferCompletion::NeedsMoreData {
                                    transfer,
                                    received,
                                    total,
                                } => {
                                    println!(
                                        "Receiving model (version {}): {}/{}",
                                        model_version, received, total
                                    );
                                    Some(transfer)
                                }
                            }
                    }
                }
            }
            NetEvent::Disconnected(_endpoint) => (),
        },
        NodeEvent::Signal(signal) => match signal {
            ThreadSignal::SendInit => {
                let init_message = MessageFromWorker::Init {};
                let init_message_bytes = bincode::serialize(&init_message).unwrap();
                handler
                    .network()
                    .send(server, init_message_bytes.as_slice());
            }
            ThreadSignal::Stop => {
                // Stops the listener, which will cause listener.for_each to return, and the thread to exit.
                handler.stop();
            }
        },
    });
}

fn handle_transfer(
    thread_data: &mut WorkerThreadData,
    model_version: ModelVersion,
    data: ParameterChunkData,
) -> TransferCompletion {
    let transfer = Option::take(&mut thread_data.transfer);
    match (thread_data.parameter_count, transfer) {
        // First chunk received, initialised transfer.
        (Some(parameter_count), None) => {
            if data.chunk_offset != 0 {
                panic!(
                    "Illegal state: Transfer began with chunk_offset({}) > 0",
                    data.chunk_offset
                );
            }
            println!("Beginning transfer of {} parameters", parameter_count);
            thread_data.transfer = Some(ModelTransfer::new(model_version, parameter_count));
            // Recursive call to handle the chunk
            handle_transfer(thread_data, model_version, data)
        }
        // Received chunk object and transfer is initialised
        (Some(_), Some(transfer)) => {
            if transfer.transfer_offset != data.chunk_offset {
                panic!("Illegal state: transfer_offset mismatch.");
            }
            transfer.receive_chunk(&data.chunk)
        }
        // Illegal states.
        (None, Some(_)) => {
            panic!("Illegal state: parameter_count not set but active transfer exists.");
        }
        (None, None) => {
            panic!("Illegal state: parameter transfer started before worker was initialised.");
        }
    }
}
