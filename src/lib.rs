pub mod common;
pub mod model;
mod noise;
mod collect_slice;

use collect_slice::CollectSlice;
use common::{MessageFromLearner, MessageFromWorker};
use message_io::events::{EventReceiver, EventSender};

use numpy::PyArray1;
use pyo3::exceptions::{PyIOError, PyValueError};
use pyo3::prelude::*;

use message_io::network::{Endpoint, NetEvent, Transport};
use message_io::node::{self, NodeEvent, NodeHandler, NodeListener};

use rand::distributions::{Standard, DistIter};
use rand::{thread_rng, Rng, SeedableRng};
use rand_xoshiro::Xoroshiro128Plus;
use rayon::prelude::ParallelIterator;
use rayon::slice::ParallelSliceMut;
use std::cell::RefCell;

use std::{io, thread};

enum Signal {
    SendInit,
}

enum SignalReplies {
    Report(String),
}

struct NoiseDescriptor {
    seed: u64,
    block_size: usize,
    block_count: usize,
}

struct ModelDescriptor {
    parameter_count: usize,
    model_version: Option<u32>,
}

struct ParameterTransfer {
    next_block_offset: usize,
    incoming_model: Box<Vec<f32>>,
    model_version: u32,
}

fn worker_thread(
    server: Endpoint,
    handler: NodeHandler<Signal>,
    listener: NodeListener<Signal>,
    replies: EventSender<SignalReplies>,
) {
    let mut noise_parameters: Option<NoiseDescriptor> = None;
    let mut model_descriptor: Option<ModelDescriptor> = None;
    let _transfer: Option<ParameterTransfer> = None;
    let _model: Option<Box<Vec<f32>>> = None;

    listener.for_each(move |event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => handler.signals().send(Signal::SendInit),
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                let message: MessageFromLearner = bincode::deserialize(data).unwrap();
                match message {
                    MessageFromLearner::InitialiseWorker {
                        seed,
                        block_size,
                        block_count,
                        parameter_count,
                    } => {
                        noise_parameters = Some(NoiseDescriptor {
                            seed,
                            block_size,
                            block_count,
                        });
                        model_descriptor = Some(ModelDescriptor {
                            parameter_count,
                            model_version: None,
                        });
                        replies.send(SignalReplies::Report("Initialising worker".to_string()));
                        replies.send(SignalReplies::Report(format!(
                            "Seed: {} Block size: {} Block count: {}",
                            seed, block_size, block_count
                        )));
                    }
                    MessageFromLearner::ParameterChunk {
                        parameter_version,
                        chunk: _,
                        chunk_offset,
                        chunk_hash: _,
                    } => {
                        replies.send(SignalReplies::Report(
                            "Received parameter chunk".to_string(),
                        ));
                        replies.send(SignalReplies::Report(format!(
                            "Parameter Version: {}",
                            parameter_version
                        )));
                        replies.send(SignalReplies::Report(format!(
                            "Chunk offset: {}",
                            chunk_offset
                        )));

                        // if let None = model_descriptor {
                        //     panic!("Received parameter chunk before model descriptor");
                        // }
                        // let Some(md) = model_descriptor;

                        // if let None = transfer {
                        //     if chunk_offset != 0 {
                        //         panic!("Received late parameter chunk before transfer started");
                        //     }
                        //     println!("Received first parameter chunk");
                        //     transfer = Some(ParameterTransfer {
                        //         next_block_offset: 0,
                        //         incoming_model: Box::new(Vec::with_capacity(md.parameter_count)),
                        //         model_version: parameter_version,
                        //     });
                        // } else {
                        //     let Some(active_transfer) = transfer;
                        //     active_transfer.incoming_model[chunk_offset..chunk_offset + chunk.len()]
                        //         .copy_from_slice(&chunk);
                        //     if active_transfer.next_block_offset == active_transfer.incoming_model.len() {
                        //         println!("Received last parameter chunk");
                        //         active_transfer.incoming_model.shrink_to_fit();
                        //         model = Some(active_transfer.incoming_model);
                        //         transfer = None;
                        //         model_descriptor = Some(ModelDescriptor {
                        //             parameter_count: md.parameter_count,
                        //             model_version: Some(parameter_version),
                        //         });
                        //     }
                        //     // Print out the progress
                        //     let progress = (chunk_offset as f32) / (md.parameter_count as f32);
                        //     println!("Received parameter chunk {:.2}%", progress * 100.0);
                        // }
                    }
                }
            }
            NetEvent::Disconnected(_endpoint) => (),
        },
        NodeEvent::Signal(signal) => match signal {
            Signal::SendInit => {
                replies.send(SignalReplies::Report("Sending initialisation".to_string()));
                let init_message = MessageFromWorker::Init {};
                let init_message_bytes = bincode::serialize(&init_message).unwrap();
                handler
                    .network()
                    .send(server, init_message_bytes.as_slice());
            }
        },
    });
}

struct WorkerLaunch(
    thread::JoinHandle<()>,
    NodeHandler<Signal>,
    EventReceiver<SignalReplies>,
);
impl
    Into<(
        thread::JoinHandle<()>,
        NodeHandler<Signal>,
        EventReceiver<SignalReplies>,
    )> for WorkerLaunch
{
    fn into(
        self,
    ) -> (
        thread::JoinHandle<()>,
        NodeHandler<Signal>,
        EventReceiver<SignalReplies>,
    ) {
        (self.0, self.1, self.2)
    }
}

fn start_background_thread(transport: Transport, addr: String) -> io::Result<WorkerLaunch> {
    let (handler, listener) = node::split::<Signal>();
    let frontside_handler = handler.clone();
    let worker_receiver = EventReceiver::default();
    let worker_downstream_sender = worker_receiver.sender().clone();
    let (server, _) = handler.network().connect(transport, addr)?;
    let thread = thread::spawn(move || {
        worker_thread(server, handler, listener, worker_downstream_sender);
    });
    Ok(WorkerLaunch(thread, frontside_handler, worker_receiver))
}

const BUFFER_SIZE: usize = 1_000_000;

#[pyclass]
struct Worker {
    // thread: thread::JoinHandle<()>,
    // handler: NodeHandler<Signal>,
    // receiver: EventReceiver<SignalReplies>,
    buffer: Vec<f32>,
}

impl Worker {
    fn new(_transport: Transport, _addr: String) -> io::Result<Worker> {
        // let (thread, handler, receiver) = start_background_thread(transport, addr)?.into();
        let mut buffer = Vec::with_capacity(BUFFER_SIZE);
        buffer.resize(BUFFER_SIZE, 0.0);

        Ok(Worker {
            // thread,
            // handler,
            // receiver,
            buffer,
        })
    }
}

type XoroshiroIterator = DistIter<Standard, Xoroshiro128Plus, f32>;

thread_local! {
    static THREAD_RNG: RefCell<XoroshiroIterator> = RefCell::new(
        Xoroshiro128Plus::from_rng(thread_rng())
        .expect("Failed to create thread rng source")
        .sample_iter(Standard)
    );
}

#[pymethods]
impl Worker {
    // fn get_signal(&mut self) -> String {
    //     match self.receiver.try_receive() {
    //         Some(SignalReplies::Report(msg)) => format!("Report: {}", msg),
    //         None => String::from("No signal"),
    //     }
    // }

    fn par_rng_generate(&mut self) {
        self.buffer.par_chunks_mut(100_000).for_each(
            |chunk: &mut [f32]| {
                THREAD_RNG.with(|rng_iter| {
                    rng_iter.borrow_mut().collect_slice(chunk);
                });
            },
        );
    }

    fn get_parameters<'py>(&mut self, py: Python<'py>) -> PyResult<&'py PyAny> {
        self.par_rng_generate();
        Ok(PyArray1::from_slice(py, &self.buffer))
    }

    // fn send_signal(&mut self, msg: String) -> PyResult<()> {
    //     // self.handler.signals().send(Signal::Worker(msg));
    //     // Ok(())
    // }
}

/// Formats the sum of two numbers as string.
#[pyfunction]
fn create_worker(connection_string: String) -> PyResult<Worker> {
    // connection_string can start with tcp:// or ws://
    // parse the connection string

    let (transport, addr) = match connection_string.split("://").next() {
        Some("tcp") => (Transport::FramedTcp, connection_string.split("://").nth(1).unwrap().to_string()),
        Some("ws") => (Transport::Ws, connection_string),
        Some("wss") => (Transport::Ws, connection_string),
        _ => return Err(PyValueError::new_err(format!("Invalid connection string: {}, expected scheme://host:port where scheme is tcp, ws or wss.", connection_string))),
    };
    match Worker::new(transport, addr) {
        Ok(worker) => Ok(worker),
        Err(err) => Err(PyIOError::new_err(format!("{}", err))),
    }
}

/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
#[pymodule]
fn fdlib(_py: Python<'_>, m: &PyModule) -> PyResult<()> {
    m.add_class::<Worker>()?;
    m.add_function(wrap_pyfunction!(create_worker, m)?)?;
    // m.add_function(wrap_pyfunction!(get_buffer, m)?)?;

    Ok(())
}
